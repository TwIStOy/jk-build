// Copyright (c) 2020 Hawtian Wang
//

#include "jk/lang/cc/compiler/cc_binary.hh"

#include <string>

namespace jk::lang::cc {

std::string MakefileCCBinaryCompiler::Name() const {
  return "Makefile.cc_binary";
}

void MakefileCCBinaryCompiler::Compile(
    core::filesystem::ProjectFileSystem *project,
    core::writer::WriterFactory *wf, core::rules::BuildRule *_rule,
    core::filesystem::FileNamePatternExpander *expander) const {
  auto rule = _rule->Downcast<core::rules::CCBinary>();
  auto working_folder = project->BuildRoot.Sub(
      utils::Replace(rule->FullQualifiedName(), '/', "@"));

  GenerateFlags(wf->Build(working_folder.Sub("flags.make").Stringify()).get(),
                rule);
  GenerateToolchain(
      wf->Build(working_folder.Sub("toolchain.make").Stringify()).get());

  GenerateBuild(project, working_folder,
                wf->Build(working_folder.Sub("build.make").Stringify()).get(),
                rule, expander);
}

void MakefileCCBinaryCompiler::GenerateBuild(
    core::filesystem::ProjectFileSystem *project,
    const common::AbsolutePath &working_folder, core::writer::Writer *w,
    core::rules::CCLibrary *rule,
    core::filesystem::FileNamePatternExpander *expander) const {
  core::output::UnixMakefile build("build.make");

  build.DefineCommon(project);

  build.Include(working_folder.Sub("flags.make").Path,
                "Include the compile flags for this rule's objectes.", true);
  build.Include(working_folder.Sub("toolchain.make").Path, "", true);

  const auto &source_files = rule->ExpandSourceFiles(project, expander);

  // headers
  std::list<std::string> all_dep_headers;
  for (auto dep : rule->DependenciesInOrder()) {
    auto vec = dep->ExportedHeaders();
    std::transform(
        vec.begin(), vec.end(), std::back_inserter(all_dep_headers),
        [project](const std::string &filename) {
          return project
              ->Resolve(common::ProjectRelativePath{fs::path{filename}})
              .Stringify();
        });
  }

  auto idx = 0;
  std::list<std::string> all_objects;
  for (const auto &filename : source_files) {
    auto source_file =
        lang::cc::SourceFile::Create(rule, rule->Package, filename);

    MakeSourceFile(project, source_file, idx, source_files.size(),
                   all_dep_headers, &build, working_folder);
    all_objects.push_back(
        source_file->FullQualifiedObjectPath(working_folder).Stringify());
    idx++;
  }

  auto binary_file = working_folder.Sub(rule->ExportedFileName);
  build.AddTarget(
      binary_file.Stringify(), all_objects,
      {"@$(PRINT) --switch=$(COLOR) --green --bold --progress-num={} "
       "--progress-total={} \"Linking binary {}\""_format(
           idx, source_files.size(), binary_file.Stringify()),
       // TODO(hawtian): deps and ldfalgs
       "$(CXX) {} {}"_format(
           binary_file.Stringify(),
           utils::JoinString(" ", all_objects.begin(), all_objects.end()))});

  auto clean_target = working_folder.Sub("clean").Stringify();
  build.AddTarget(clean_target, {},
                  {"$(RM) {}"_format(binary_file.Stringify())}, "", true);

  auto build_target = working_folder.Sub("build").Stringify();
  build.AddTarget(build_target, {binary_file.Stringify()}, {},
                  "Rule to build all files generated by this target.", true);

  build.Write(w);
}

}  // namespace jk::lang::cc

// vim: fdm=marker

