// Copyright (c) 2020 Hawtian Wang
//

#include "jk/lang/cc/compiler/cc_binary.hh"

#include <string>

#include "jk/common/counter.hh"
#include "jk/core/rules/package.hh"
#include "jk/lang/cc/rules/cc_library_helper.hh"

namespace jk::lang::cc {

std::string MakefileCCBinaryCompiler::Name() const {
  return "Makefile.cc_binary";
}

void MakefileCCBinaryCompiler::Compile(
    core::filesystem::ProjectFileSystem *project,
    core::writer::WriterFactory *wf, core::rules::BuildRule *_rule,
    core::filesystem::FileNamePatternExpander *expander) const {
  auto rule = _rule->Downcast<core::rules::CCBinary>();
  auto working_folder = rule->WorkingFolder(project->BuildRoot);

  GenerateFlags(wf->Build(working_folder.Sub("flags.make").Stringify()).get(),
                rule);
  GenerateToolchain(
      wf->Build(working_folder.Sub("toolchain.make").Stringify()).get());

  GenerateBuild(project, working_folder,
                wf->Build(working_folder.Sub("build.make").Stringify()).get(),
                rule, expander);
}

core::output::UnixMakefilePtr MakefileCCBinaryCompiler::GenerateBuild(
    core::filesystem::ProjectFileSystem *project,
    const common::AbsolutePath &working_folder, core::writer::Writer *w,
    core::rules::CCLibrary *_rule,
    core::filesystem::FileNamePatternExpander *expander) const {
  auto rule = _rule->Downcast<core::rules::CCBinary>();
  core::output::UnixMakefilePtr build(
      new core::output::UnixMakefile{"build.make"});

  build->DefineCommon(project);

  build->Include(working_folder.Sub("flags.make").Path,
                 "Include the compile flags for this rule's objectes.", true);
  build->Include(working_folder.Sub("toolchain.make").Path, "", true);

  const auto &source_files = rule->ExpandSourceFiles(project, expander);

  // headers
  std::list<std::string> all_dep_headers = MergeDepHeaders(rule, project);
  std::list<uint32_t> progress_num;

  auto counter = common::Counter();

  // lint files first
  for (const auto &filename : source_files) {
    auto source_file =
        lang::cc::SourceFile::Create(rule, rule->Package, filename);

    progress_num.push_back(
        LintSourceFile(project, source_file, build.get(), working_folder));
    progress_num.push_back(source_file->ProgressNum);
  }

  auto clean_target = working_folder.Sub("clean").Stringify();
  std::list<std::string> clean_statements;

  auto binary_progress_num = counter->Next();
  for (const auto &build_type : BuildTypes) {
    std::list<std::string> all_objects;
    for (const auto &filename : source_files) {
      auto source_file =
          lang::cc::SourceFile::Create(rule, rule->Package, filename);

      MakeSourceFile(project, build_type, source_file, all_dep_headers,
                     build.get(), working_folder);
      all_objects.push_back(
          source_file->FullQualifiedObjectPath(working_folder, build_type)
              .Stringify());
    }
    auto binary_file =
        working_folder.Sub(build_type).Sub(rule->ExportedFileName);
    auto deps_and_flags =
        rule->ResolveDependenciesAndLdFlags(project->BuildRoot, build_type);

    auto binary_deps = all_objects;
    for (auto dep : rule->Dependencies) {
      auto names = dep->ExportedFilesSimpleName();
      auto dep_working_folder = dep->WorkingFolder(project->BuildRoot);
      for (const auto &name : names) {
        binary_deps.push_back(
            dep_working_folder.Sub(build_type).Sub(name).Stringify());
      }
    }
    build->AddTarget(
        binary_file.Stringify(), binary_deps,
        {"@$(PRINT) --switch=$(COLOR) --green --bold --progress-num={} "
         "--progress-total={} \"Linking binary {}\""_format(
             utils::JoinString(",", progress_num), project->BuildRoot,
             binary_file.Stringify()),
         "$(LINKER) -o {} {} {}"_format(
             binary_file.Stringify(),
             utils::JoinString(" ", all_objects.begin(), all_objects.end()),
             utils::JoinString(" ", deps_and_flags.begin(),
                               deps_and_flags.end()))});
    clean_statements.push_back("$(RM) {}"_format(binary_file.Stringify()));
    for (const auto &obj : all_objects) {
      clean_statements.push_back("$(RM) {}"_format(obj));
    }

    auto build_target = working_folder.Sub(build_type).Sub("build").Stringify();
    build->AddTarget(build_target, {binary_file.Stringify()}, {},
                     "Rule to build all files generated by this target.", true);
  }

  build->AddTarget(clean_target, {}, clean_statements, "", true);

  build->Write(w);

  return build;
}

}  // namespace jk::lang::cc

// vim: fdm=marker

