// Copyright (c) 2020 Hawtian Wang
//

#include "jk/core/builder/makefile_builder.hh"

#include <fstream>
#include <iterator>
#include <sstream>
#include <string>
#include <vector>

#include "fmt/core.h"
#include "jk/core/filesystem/project.hh"
#include "jk/core/rules/package.hh"
#include "jk/core/writer/writer.hh"
#include "jk/utils/str.hh"
#include "jk/version.h"

namespace jk {
namespace core {
namespace builder {

using fmt::operator""_format;

static const char *CommonHeader[] = {
    "# JK generated file: DO NOT EDIT!",
    "# Generated by \"Unix Makefiles\" Generator, JK Version " JK_VERSION};
static const char *Separator =
    "#========================================================================="
    "====";

static void WriteHeader(writer::Writer *w) {
  for (const auto &line : CommonHeader) {
    w->WriteLine(line);
  }
  w->WriteLine(Separator)->NewLine();
}

static void WriterComment(writer::Writer *w, const std::string &str) {
  if (str.length()) {
    w->WriteLineF("# {}", str);
  }
}

struct ElementVisitor : public boost::static_visitor<std::string> {
  std::string operator()(compile::ir::DefinedVariable *v) const {
    return "$({})"_format(v->Key);
  }

  std::string operator()(const std::string &s) const {
    return s;
  }
};

/*
 * Page 'build'
 */
void MakefileBuilder::WriteIR(filesystem::ProjectFileSystem *project,
                              rules::BuildRule *rule, compile::ir::IR *ir,
                              writer::WriterFactory *writer_factory) {
  auto root = project->BuildRoot.Sub(
      utils::Replace(rule->FullQualifiedName(), '/', "@"));

  std::vector<std::string> env_only;
  for (const auto &[key, _] : ir->Environments) {
    auto it = ir->Pages.find(key);
    if (it == ir->Pages.end()) {
      env_only.push_back(key);
    }
  }

  for (const auto &name : env_only) {
    auto w = writer_factory->Build("{}/{}.make"_format(root, name));

    WriteHeader(w.get());
    for (const auto &[_, v] : ir->Environments[name].Vars) {
      WriterComment(w.get(), v->Comment);
      w->WriteLineF("{} = {}", v->Key, v->Value);
    }
  }

  for (const auto &[name, page] : ir->Pages) {
    auto w = writer_factory->Build("{}/{}.make"_format(root, name));

    WriteHeader(w.get());
    for (const auto &[_, v] : ir->Environments[name].Vars) {
      WriterComment(w.get(), v->Comment);
      w->WriteLineF("{} = {}", v->Key, v->Value)->NewLine();
    }

    // includes
    for (const auto &inc : page.Includes) {
      WriterComment(w.get(), inc.Comments);
      if (inc.Fatal) {
        w->WriteLineF("include {}/{}.make", root, inc.Tag);
      } else {
        w->WriteLineF("-include {}/{}.make", root, inc.Tag);
      }
    }

    auto idx = 0;
    auto total = page.Targets.size();
    for (const auto &tgt : page.Targets) {
      w->NewLine();
      WriterComment(w.get(), tgt.Comments);

      w->WriteLineF("{}: {}", tgt.Name,
                    utils::JoinString(" ", std::begin(tgt.Dependencies),
                                      std::end(tgt.Dependencies)));

      for (const auto &stmt : tgt.Statements) {
        w->WriteLineF(
            "\t@$(PRINT) --switch=$(COLOR) --green --bold --progress-num={} "
            "--progress-total={} \"{}\"",
            idx, total, stmt.Hint);

        w->WriteLineF("\t{}",
                      utils::JoinString(
                          " ", stmt.Elements.begin(), stmt.Elements.end(),
                          [](const compile::ir::StmtElement &e) {
                            return boost::apply_visitor(ElementVisitor{}, e);
                          }));
      }

      if (tgt.Phony) {
        w->WriteLineF(".PHONY : {}", tgt.Name);
      }
    }
  }
}

}  // namespace builder
}  // namespace core
}  // namespace jk

